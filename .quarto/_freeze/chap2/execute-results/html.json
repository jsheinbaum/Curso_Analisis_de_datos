{
  "hash": "6d9edb93cd71123f2bbb94feab9d3bc9",
  "result": {
    "markdown": "---\ntitle: \"Test Reveal Presentations\"\nauthor: \"Julio\"\nsubtitle: \"Testing stuff\"\nformat:\n  revealjs: \n    theme: solarized\n    slide-number: true\n    chalkboard: true \n    buttons: false\n    preview-links: auto\n    css: styles.css\n    footer: <https://quarto.org>\n---\n\n## Empieza \n\n- Turn on Math\n- $Ax=b$\n\n- Cauchy-Shwarz\n\n$$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$$ \n\n## More Math\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n- A Cross Product Formula\n\n$$\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n  \\mathbf{\\hat i} &  \\mathbf{\\hat j} & \\mathbf{\\hat k} \\\\\n  \\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n  \\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0\n  \\end{vmatrix}  $$\n:::\n\n::: {.column width=\"40%\"}\n- The Lorenz Equations\n$$\n\\begin{aligned}\n  \\dot{x} & = \\sigma(y-x) \\\\\n  \\dot{y} & = \\rho x - y - xz \\\\\n  \\dot{z} & = -\\beta z + xy\n  \\end{aligned}\n$$\n:::\n\n::::\n\n## Julia\n\n```{julia}\n#| echo: true\nusing GLMakie\n\nBase.@kwdef mutable struct Lorenz\n    dt::Float64 = 0.01\n    σ::Float64 = 10\n    ρ::Float64 = 28\n    β::Float64 = 8/3\n    x::Float64 = 1\n    y::Float64 = 1\n    z::Float64 = 1\nend\n\nfunction step!(l::Lorenz)\n    dx = l.σ * (l.y - l.x)\n    dy = l.x * (l.ρ - l.z) - l.y\n    dz = l.x * l.y - l.β * l.z\n    l.x += l.dt * dx\n    l.y += l.dt * dy\n    l.z += l.dt * dz\n    Point3f(l.x, l.y, l.z)\nend\n\nattractor = Lorenz()\n\npoints = Observable(Point3f[])\ncolors = Observable(Int[])\n\nset_theme!(theme_black())\n\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true,\n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0),\n        viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz.mp4\", 1:120) do frame\n    for i in 1:50\n        push!(points[], step!(attractor))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120)\n    notify.((points, colors))\n    l.colorrange = (0, frame)\nend\n```\n\n## Lorenz Atractor {background-video=\"lorenz.mp4\"  background-video-loop=\"true\"}\n\n---\nformat: \n  html:\n    code-fold: true\njupyter: python3\n---\n\n## Polar Axis\n\nFor a demonstration of a line plot on a polar axis, see @fig-polar.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![A line plot on a polar axis](chap2_files/figure-html/fig-polar-output-1.png){#fig-polar width=445 height=438}\n:::\n:::\n\n\n## Python\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](chap2_files/figure-html/cell-3-output-1.png){width=445 height=438}\n:::\n:::\n\n\n## GFS Download and Plot\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n\n::: {.cell output-location='slide' execution_count=3}\n``` {.python .cell-code}\n#| label: xarray plot\n#| fig-cap: \"xarray demo\"\nimport xarray as xr\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nfrom matplotlib.animation import FuncAnimation\nvariables=['u-component_of_wind_height_above_ground','v-component_of_wind_height_above_ground']\ndsw=xr.open_dataset('https://thredds.ucar.edu/thredds/dodsC/grib/NCEP/GFS/Global_0p25deg/Best')[variables]\nfrom datetime import datetime, timedelta\nstarttime=datetime.utcnow()\nstarttime\ninittime = datetime.utcnow().date().isoformat()   ### Simulation startime..\nendtime = starttime + timedelta(days=10)\nfinaltime=endtime.date().isoformat()\nprint(inittime)\nprint(finaltime)\nlat_toplot = np.arange(5, 35.25, 0.25) # last number is exclusive\nlon_toplot = np.arange(260, 310.25, 0.25) # last number is exclusive\ndataw= dsw.sel(time=slice(inittime,finaltime),height_above_ground2=10, lon=lon_toplot, lat=lat_toplot)\nu10=dataw['u-component_of_wind_height_above_ground'].values\nv10=dataw['v-component_of_wind_height_above_ground'].values\nlon=dataw.lon.values\nlat=dataw.lat.values\nl=10\nU10=u10[l,:,:].squeeze()\nV10=v10[l,:,:].squeeze()\nvec_crs = ccrs.RotatedPole(pole_longitude=180.0, pole_latitude=90.0)\n#central_rotated_longitude=0.0)\ndata_crs=ccrs.PlateCarree()\n#print(dataw.time[l])\nfig = plt.figure(figsize=(20, 5))\nax1 = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())\nax1.set_extent([260, 311, 4, 40], crs=ccrs.PlateCarree())\nax1.coastlines()\nmagnitude = (U10 ** 2 + V10 ** 2) ** 0.5\n#magnitude.shape\nax1.streamplot(lon, lat, U10, V10, transform=vec_crs,\n                  linewidth=2, density=2, color=magnitude)\nax1.quiver(lon[::5],lat[::5],U10[::5,::5],V10[::5,::5],scale=200.0,color='b',transform=data_crs)\nplt.savefig('foo.png', bbox_inches='tight')\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-12-22\n2024-01-01\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](chap2_files/figure-html/cell-4-output-2.png){width=543 height=389}\n:::\n:::\n\n\n::: \n\n::::\n\n",
    "supporting": [
      "chap2_files"
    ],
    "filters": [],
    "includes": {}
  }
}